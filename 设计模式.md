# 设计模式

## 1. 面向对象的设计原则

### 1.开闭原则 OCP

> 模块是可扩展的, 而不可修改. **即软件应尽量在不修改原有代码的情况下进行扩展.**

- 抽象化是开闭原则的关键.
- 用抽象构建框架, 用实现扩展细节.
- 通过抽象类, 接口定义系统抽象层, 再通过具体类来进行扩展, 如果需要修改系统的行为, 无需对抽象层进行任何改动.

### 2.里氏替换原则 LSP

> 所有引用基类对象的地方能够透明地使用其子类对象

- 继承可以使子类拥有父类的方法和属性, 减少创建类的工作量, 提高了代码的重用性. 但是继承是侵入性的, 降低了代码的灵活性, 增加了耦合.当对父类代码修改时, 必须考虑到对子类产生的影响.
- 里氏替换原则可以对继承进行规则上的约束
  - 子类必须实现父类的抽象放方法, 但不得重写父类的非抽象方法;
  - 子类可以增加自己的特有方法;
- 在软件中将一个基类对象替换成它的子类对象, 程序将不会产生任何错误和异常.
- 由于使用基类对象的地方都可以使用子类对象, 因此在程序中尽量使用基类类型来对对象进行定义.

### 3.依赖倒置原则 DIP

> 高层模块不应该依赖于底层模块的实现, 而应该依赖于底层的抽象.
>
> 例如: 开关不应该依赖于电灯的开关实现, 而是应该依赖于一个抽象的开关标准接口;

- 核心: 面向接口编程

```java
/*
  张三是你的司机，负责开你的宝马.
*/
class Driver{
    void driveBMW();
}
/*
  但有一天你又买了辆奔驰，这下完蛋了，张三没有开奔驰的方法.
  显然你不能再招一个专门开奔驰的司机，或者说去修改张三的基因，让他会开奔驰.
*/
class Driver {
    void briveBMW();
    void driveBenz();
}
/*
  正确的做法是抽象出汽车对象，让宝马和奔驰实现汽车抽象。然后让Driver依赖汽车抽象。
  这样只要在出差前，注入相应的汽车，张三就可以开动了。即使以后你买了兰博基尼也不用去动张三。
*/
class Driver {
    Car car;
    void drive(){ this.car.run();}
}
```

### 4.单一职责原则 SRP

> 一个类, 只做好一件事, 并把这件事做好, 其只有一个引起它变化的原因.

- 将职责定义为引起变化的原因, 以调高内聚性来减少引起变化的原因.

### 5.接口隔离原则 ISP

> 把功能声明在接口中, 而不是类中;
>
> 使用多个专门的接口比使用单一的总接口要好.

- 不要建立庞大臃肿的接口;
- 尽量细化接口, 接口中的方法尽量少;
- 接口中的方法数量一定要适度;

### 6.迪米特原则(最少知识原则)

> 一个软件实体应当尽可能少地与其他实体发生相互作用

- 尽量降低类与类之间的耦合, 尽量创建松耦合的类;
- 每一个类都应当尽量降低其成员变量和成员函数的访问权限.
- 尽量减少`public`;

## 2.创建型设计模式

### 1.简单工厂

- 由一个工厂对象决定创建出哪一种产品类的实例, 客户端只负责传入参数, 不用关心创建对象的逻辑
- 实际使用: `java.text.DateFormat`

```java
// Product 为产品抽象
class SimpleFactory(){
  public Product produce(String tyep) {
    switch(type){
      case 0:
        return new Product1();
      case 1:
        return new Product2();
      default:
        return nil;
    }
  }
}
```

### 2.工厂方法

> 又称工厂模式, 工厂父类负责定义创建产品对象的公共接口, 工厂子类负责生成具体的产品对象. 具体的工厂子类来确定究竟应该实例化哪一个具体的产品类.

- 用户仅仅关心产品对应的具体工厂即可, 不需要关心产品的创建细节, 也不需要知道具体产品的类名.
- 方便扩展, 增加新产品.

```java
// 父类负责定义创建产品对象的公共接口
abstract class Factory {
  public abstract Product produce();
}

// 子类工厂A负责生成具体产品A的实例化
class AFactory extends Factory{
  @Override
  public Product produce() {
    return new ProductA()
  }
}

// 子类工厂B负责生成具体产品B的实例化
class BFactory extends Factory{
  @Override
  public Product produce() {
    return new ProductB()
  }
}
```

### 3.抽象工厂

> 提供一个创建一系列相关或相互依赖对象的接口, 例如: 海尔工厂可以创建海尔空调, 海尔冰箱, 海尔洗衣机.

- 产品等级: 即产品的继承结构, 一个抽象的电视机和具体品牌的电视机构成一个产品等级结构. 抽象电视机是父类, 品牌电视机是其子类.
- 产品族: 指一个工厂生产, 位于不同产品等级结构中的产品. 如海尔冰箱, 海尔空调, 海尔电视机.
- 抽象工厂提供一个创建一系列相关或相互依赖对象的接口, 用户可以快速简单的创建所有所需的产品

```java
// 父类: 定义一系列产品(Product1, Product2)的创建
abstract class Factory {
  public abstract Product1 produce1();
  public abstract Product2 produce2();
}

// 子类工厂A, 负责生成 A品牌的Product1, A品牌的Product2
class AFactory extends Factory {
  @Override
  public Product1 produce1() {
    return new ProductA1();
  }

  @Override
  public Product2 produce2() {
    return new ProductA2();
  }
}
```

### 4.单例

> 确保类只有一个实例, 并提供一个访问它的全局访问方式.

- 单例模式的重点
  - 必须设置构造器为私有构造器, 防止客户端直接实例化对象;
  - 线程安全;
  - 延迟加载;
  - 序列化和反序列化安全;
  - 反射
- 线程锁懒汉式:

  ```java
  /* 懒汉式单例模式 */
  public class LazySingleton {
    /* 静态私有属性, 用于存放实例 */
    private static LazySingleton lazySingleton = null;

    /* 私有构造方法 */
    private LazySingleton(){

    }

    /* 全局访问实例方式, 加线程锁, 保证线程安全 */
    public synchronized static LazySingleton getInstance() {
      if (lazySingleton==null)
        lazySingleton = new LazySingleton();
      return lazySingleton;
    }
  }
  ```

- DoubleCheck 双重检查懒汉式单例

  ```java
  /* 懒汉式单例模式 */
  public class LazySingleton {
    /* 静态私有属性, 用于存放实例 *使用volatile修饰* */
    private volatile static LazySingleton lazySingleton = null;

    /* 私有构造方法 */
    private LazySingleton(){

    }

    /* 全局访问实例方式, 加线程锁, 保证线程安全 */
    public static LazySingleton getInstance() {
      if (lazySingleton == null) {
        synchronized(LazySingleton.class){
          if(lazySingleton == null){
            lazySingleton = new LazySingleton();
          }
        }
      }
      return lazySingleton;
    }
  }
  ```

- 静态内部类的单例模式

  ```java
  public class StaticInnerClassSingleton {
    /* 静态内部类 */
    private static class InnerClass {
      private static StaticInnerClassSingleton instance = new StaticInnerClassSingleton;
    }

    public static getInstance() {
      return InnerClass.instance;
    }
  }
  ```

- 饿汉式单例模式

  ```java
  public class HungrySingleton {
    private final static HungrySingleton instance = new HungrySingleton();

    private HungrySingleton() {

    }

    public static HungrySingleton getInstance() {
      return instance;
    }
  }
  ```

### 5.建造者模式

> 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

- 组成产品的零件(参数)的构建过程客户端可以不用感知组成产品的具体零件, 交由构建者去生产并组合成产品;
- 某些情况下, 一个对象的一些性质必须按照某个顺序赋值才有意义, 或者说赋值的顺序不同, 产生的效果不一致; 这时就需要将这些属性的构造"外部化"到建造者对象里.

## 3.结构型模式

### 1.适配器模式

> 将一个接口转换成客户希望的另一接口, 使接口不兼容的类可以一种工作.

### 2.装饰模式

> 可以动态的将不同的职责(装饰类) 附加到对象上, 从而扩展对象功能.
>
> 被装饰者和装饰者应具有相同的超类, 应为装饰者必和被装饰者应具有相同的接口.
>
> 

- 角色:
  - Component: 抽象构建, 表示规范准备接收附加责任的对象.
  - ConcreteComponent: 具体构建. 继承抽象构建的的具体类.
  - Decorator: 装饰器, 继承抽象构建.
  - ConcreteDecorator: 具体装饰器.

```java
/* 抽象构建 */
abstract class Component {
  public abstract void operation();
}

/* 具体构建, 继承抽象构建的具体类. 实现抽象方法 */
class ConcreteComponent extends Component {
  @Override
  public void operation(){
    System.out.println("...");
  }
}

/* 装饰器, 继承抽象构建(里氏替换原则) */
class Decorator extends Component {
  /* 保存需要装饰的具体构建(protected 保证子类可以访问) */
  protected Component component;
  public Decorator(Component component) {
    this.component = component;
  }

  /* 具体装饰器(ConcreteDecorator)通过重写该方法, 可以在父类方法基础上, 做出额外操作 */
  @Override
  public void operation(){
    this.component.operation();
  }
}
```

### 3.外观模式

> 外部与一个子系统的通信必须通过一个**统一的外观对象**进行, 为子系统中的一组接口提供一个一致的界面(迪米特法则, 将内部子系统的相关逻辑操作隐藏, 仅对外暴露一个外观角色类).
>
> 定义了一个高层接口, 这个接口使得这一子系统更加容易使用.

- 角色:
  - Facade: 外观角色.
  - SubSystem: 子系统角色.

### 4.代理模式

#### 1.静态代理

- 为每个类编写一个**对应的代理类**, 并且让代理类实现和目标类相同的接口.

- 代理对象 = 增强代码+ 目标对象

- 缺陷: 要手动为每一个目标类编写对应的代理类

#### 2.动态代理

- 通过`Proxy.newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)`创建接口(interfaces)对应的代理类.
    - `loader = target.getClass().getClassLoader()`
    - `interfaces = target.getClass().getInterfaces()`
- 动态代理可以在不扩展代码的情况下, 为不同的类, 不同的接口提供相同的功能扩展.

## 4.行为型模式

### 1.命令模式

> 将**请求**封装为**对象**, 从而让我们可以用不同的请求对客户进行参数化(能够识别所有的请求), 对请求排队或者记录请求日志, 以及支持可撤销的操作. 又称为动作模式或事物模式.

- 接收者(Receiver): 负责具体实施和执行的一个请求. 一个具体的命令执行会转换为一个接收者的方法;
- 请求者(Invoker): 负责调用命令对象执行请求.
- 命令(Command): 抽象接口, 定义所有具体命令的执行接口.
- 具体命令(ConcreteCommand): 定义一个接受者和行为之间的弱耦合, 在执行方法中调用**接收者**的相应操作.

```java
/* 接收者 */
class Receiver {
  public void off() {
    System.out.println("off");
  }

  public void on() {
    System.out.println("on");
  }
}
/* 通过定义接口, 定义参数(命令)的执行方法 */
interface Command{
  void execute();
}

/* 实现Command方法, 通过调用接收者的相应操作, 实现具体功能 */
class OnCommand implements Command{
  private Receiver receiver;
  @Override
  void execute(){
    receiver.on();
  }
}

/* 实现Command方法, 通过调用接收者的相应操作, 实现具体功能 */
class OffCommand implements Command{
  private Receiver receiver;
  @Override
  void execute(){
    receiver.off();
  }
}

```

- 源码中的应用:`Runnable`

### 2.观察者模式

> 定义对象之间的一种一对多依赖关系, 使得当一个对象状态发生变化时, 其相关依赖对象都会收到通知并自动更新.
>
> 观察者模式的别名包括: 发布-订阅模式, 模型-视图(Model/View)模式, 源-监听器模式

- `Observer`: 观察者接口, 定义`update`方法, 当被观察对象发生更新时通过该方法通知到观察者.
- `Observable`: 被观测对象, 包含:
  - `addObserver()`: 添加观察者;
  - `eleteObserver()`: 删除观察者;
  - `notifyObserver()`: 通知观察者;
  - `setChanged()`标识被观测对象变化;
  - 一个包含所有注册的观察者的容器;

### 3.状态模式

> 允许一个对象在其内部状态改变时改变它的行为, 对象看起来似乎修改了它的类.

- 状态模式包含如下角色:
  - `Context`: 环境角色, 也称为上下文, 定义**客户端所感兴趣的接口**, 并保留一个具体状态类的实例(表明当前状态)
  - `State`: 抽象状态类, 定义`Context`对象的一个特定状态所对象的行为.
  - `ConcreteState`: 具体状态类, 实现具体状态下的行为.

```java
/* 抽象状态类 */
abstract class State {
  /* 包含一个上下文信息, 子类状态中的方法可以访问上下文, 从而切换状态 */
  protected Context context;

  public void setContext(Context context) {
    this.context = context;
  }

  public abstract void run();
  public abstract void stop();
}

/* 上下文, 存储当前状态信息. 对用户做出合理响应 */
class Context {
  /* 定义状态常量, 方便切换状态是赋值 */
  public static final RunState RUNSTATE = new RunState();
  public static final StopState STOPSTATE = new StopState();

  /* 用于保存当前状态 */
  private State state;
  public void setState(State state){
    this.state = state;
    this.state.setContext(this);
  }

  /* 用户感兴趣的接口 */
  public void run() {
    this.state.run();
  }

  public void stop() {
    this.state.stop();
  }
}

/* 具体实现一种状态(RunState), 实现当前状态下具体的行为表现 */
class RunState extends State {
  @Override
  public void run(){
    System.out.println("已经启动");
  }

  @Override
  public void stop(){
    super.context.setState(Context.STOPSTATE);
    System.out.println("停止");
  }
}

/* 具体实现一种状态(StopState) */
class StopState extends State {
  @Override
  public void run() {
    super.context.setState(Context.RUNSTATE);
    System.out.println("启动");
  }

  @Override
  public void stop(){
    System.out.println("已经停止");
  }
}
```
