# 设计模式

## 1. 面向对象的设计原则

### 1.开闭原则 OCP

> 模块是可扩展的, 而不可修改. **即软件应尽量在不修改原有代码的情况下进行扩展.**

- 抽象化是开闭原则的关键.
- 用抽象构建框架, 用实现扩展细节.
- 通过抽象类, 接口定义系统抽象层, 再通过具体类来进行扩展, 如果需要修改系统的行为, 无需对抽象层进行任何改动.

### 2.里氏替换原则 LSP

> 所有引用基类对象的地方能够透明地使用其子类对象

- 继承可以使子类拥有父类的方法和属性, 减少创建类的工作量, 提高了代码的重用性. 但是继承是侵入性的, 降低了代码的灵活性, 增加了耦合.当对父类代码修改时, 必须考虑到对子类产生的影响.
- 里氏替换原则可以对继承进行规则上的约束
  - 子类必须实现父类的抽象放方法, 但不得重写父类的非抽象方法;
  - 子类可以增加自己的特有方法;
- 在软件中将一个基类对象替换成它的子类对象, 程序将不会产生任何错误和异常.
- 由于使用基类对象的地方都可以使用子类对象, 因此在程序中尽量使用基类类型来对对象进行定义.

### 3.依赖倒置原则 DIP

> 高层模块不应该依赖于底层模块的实现, 而应该依赖于底层的抽象.
>
> 例如: 开关不应该依赖于电灯的开关实现, 而是应该依赖于一个抽象的开关标准接口;

- 核心: 面向接口编程

```java
/*
  张三是你的司机，负责开你的宝马.
*/
class Driver{
    void driveBMW();
}
/*
  但有一天你又买了辆奔驰，这下完蛋了，张三没有开奔驰的方法.
  显然你不能再招一个专门开奔驰的司机，或者说去修改张三的基因，让他会开奔驰.
*/
class Driver {
    void briveBMW();
    void driveBenz();
}
/*
  正确的做法是抽象出汽车对象，让宝马和奔驰实现汽车抽象。然后让Driver依赖汽车抽象。
  这样只要在出差前，注入相应的汽车，张三就可以开动了。即使以后你买了兰博基尼也不用去动张三。
*/
class Driver {
    Car car;
    void drive(){ this.car.run();}
}
```

### 4.单一职责原则 SRP

> 一个类, 只做好一件事, 并把这件事做好, 其只有一个引起它变化的原因.

- 将职责定义为引起变化的原因, 以调高内聚性来减少引起变化的原因.

### 5.接口隔离原则 ISP

> 把功能声明在接口中, 而不是类中;
>
> 使用多个专门的接口比使用单一的总接口要好.

- 不要建立庞大臃肿的接口;
- 尽量细化接口, 接口中的方法尽量少;
- 接口中的方法数量一定要适度;

### 6.迪米特原则(最少知识原则)

> 一个软件实体应当尽可能少地与其他实体发生相互作用

- 尽量降低类与类之间的耦合, 尽量创建松耦合的类;
- 每一个类都应当尽量降低其成员变量和成员函数的访问权限.
- 尽量减少`public`;

## 2.创建型设计模式

### 1.简单工厂

- 由一个工厂对象决定创建出哪一种产品类的实例, 客户端只负责传入参数, 不用关心创建对象的逻辑
- 实际使用: `java.text.DateFormat`

```java
// Product 为产品抽象
class SimpleFactory(){
  public Product produce(String tyep) {
    switch(type){
      case 0:
        return new Product1();
      case 1:
        return new Product2();
      default:
        return nil;
    }
  }
}
```

### 2.工厂方法

> 又称工厂模式, 工厂父类负责定义创建产品对象的公共接口, 工厂子类负责生成具体的产品对象. 具体的工厂子类来确定究竟应该实例化哪一个具体的产品类.

- 用户仅仅关心产品对应的具体工厂即可, 不需要关心产品的创建细节, 也不需要知道具体产品的类名.
- 方便扩展, 增加新产品.

```java
// 父类负责定义创建产品对象的公共接口
abstract class Factory {
  public abstract Product produce();
}

// 子类工厂A负责生成具体产品A的实例化
class AFactory extends Factory{
  @Override
  public Product produce() {
    return new ProductA()
  }
}

// 子类工厂B负责生成具体产品B的实例化
class BFactory extends Factory{
  @Override
  public Product produce() {
    return new ProductB()
  }
}
```

### 3.抽象工厂

> 提供一个创建一系列相关或相互依赖对象的接口, 例如: 海尔工厂可以创建海尔空调, 海尔冰箱, 海尔洗衣机.

- 产品等级: 即产品的继承结构, 一个抽象的电视机和具体品牌的电视机构成一个产品等级结构. 抽象电视机是父类, 品牌电视机是其子类.
- 产品族: 指一个工厂生产, 位于不同产品等级结构中的产品. 如海尔冰箱, 海尔空调, 海尔电视机.
- 抽象工厂提供一个创建一系列相关或相互依赖对象的接口, 用户可以快速简单的创建所有所需的产品

```java
// 父类: 定义一系列产品(Product1, Product2)的创建
abstract class Factory {
  public abstract Product1 produce1();
  public abstract Product2 produce2();
}

// 子类工厂A, 负责生成 A品牌的Product1, A品牌的Product2
class AFactory extends Factory {
  @Override
  public Product1 produce1() {
    return new ProductA1();
  }

  @Override
  public Product2 produce2() {
    return new ProductA2();
  }
}
```

### 4.单例

> 确保类只有一个实例, 并提供一个访问它的全局访问方式.

- 单例模式的重点
  - 必须设置构造器为私有构造器, 防止客户端直接实例化对象;
  - 线程安全;
  - 延迟加载;
  - 序列化和反序列化安全;
  - 反射
- 线程锁懒汉式:

  ```java
  /* 懒汉式单例模式 */
  public class LazySingleton {
    /* 静态私有属性, 用于存放实例 */
    private static LazySingleton lazySingleton = null;

    /* 私有构造方法 */
    private LazySingleton(){

    }

    /* 全局访问实例方式, 加线程锁, 保证线程安全 */
    public synchronized static LazySingleton getInstance() {
      if (lazySingleton==null)
        lazySingleton = new LazySingleton();
      return lazySingleton;
    }
  }
  ```

- DoubleCheck 双重检查懒汉式单例

  ```java
  /* 懒汉式单例模式 */
  public class LazySingleton {
    /* 静态私有属性, 用于存放实例 *使用volatile修饰* */
    private volatile static LazySingleton lazySingleton = null;

    /* 私有构造方法 */
    private LazySingleton(){

    }

    /* 全局访问实例方式, 加线程锁, 保证线程安全 */
    public static LazySingleton getInstance() {
      if (lazySingleton == null) {
        synchronized(LazySingleton.class){
          if(lazySingleton == null){
            lazySingleton = new LazySingleton();
          }
        }
      }
      return lazySingleton;
    }
  }
  ```

- 静态内部类的单例模式

  ```java
  public class StaticInnerClassSingleton {
    /* 静态内部类 */
    private static class InnerClass {
      private static StaticInnerClassSingleton instance = new StaticInnerClassSingleton;
    }

    public static getInstance() {
      return InnerClass.instance;
    }
  }
  ```

- 饿汉式单例模式

  ```java
  public class HungrySingleton {
    private final static HungrySingleton instance = new HungrySingleton();

    private HungrySingleton() {

    }

    public static HungrySingleton getInstance() {
      return instance;
    }
  }
  ```

### 5.建造者模式

> 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

- 组成产品的零件(参数)的构建过程客户端可以不用感知组成产品的具体零件, 交由构建者去生产并组合成产品;
- 某些情况下, 一个对象的一些性质必须按照某个顺序赋值才有意义, 或者说赋值的顺序不同, 产生的效果不一致; 这时就需要将这些属性的构造"外部化"到建造者对象里.

## 3.结构型模式

### 1.适配器模式

### 2.装饰模式

### 3.外观模式

## 4.行为型模式

### 1.命令模式

### 2.观察者模式

> 定义对象之间的一种一对多依赖关系, 使得当一个对象状态发生变化时, 其相关依赖对象都会收到通知并自动更新.
>
> 观察者模式的别名包括: 发布-订阅模式, 模型-视图(Model/View)模式, 源-监听器模式

- `Observer`: 观察者接口, 定义`update`方法, 当被观察对象发生更新时调用该方法.
- `Observable`: 被观测对象, 包含:
  - `addObserver()`: 添加观察者;
  - `eleteObserver()`: 删除观察者;
  - `notifyObserver()`: 通知观察者;
  - `setChanged()`标识被观测对象变化;
  - 一个包含所有观察者的容器;
